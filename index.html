<!DOCTYPE html><html class="default"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>ucan-storage</title><meta name="description" content="Documentation for ucan-storage"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script async src="assets/search.js" id="search-script"></script></head><body><script>document.body.classList.add(localStorage.getItem("tsd-theme") || "os")</script><header><div class="tsd-page-toolbar"><div class="container"><div class="table-wrap"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget search no-caption">Search</label><input type="text" id="tsd-search-field"/></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">ucan-storage</a></div><div class="table-cell" id="tsd-widgets"><div id="tsd-filter"><a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a><div class="tsd-filter-group"><div class="tsd-select" id="tsd-filter-visibility"><span class="tsd-select-label">All</span><ul class="tsd-select-list"><li data-value="public">Public</li><li data-value="protected">Public/Protected</li><li data-value="private" class="selected">All</li></ul></div> <input type="checkbox" id="tsd-filter-inherited" checked/><label class="tsd-widget" for="tsd-filter-inherited">Inherited</label><input type="checkbox" id="tsd-filter-externals" checked/><label class="tsd-widget" for="tsd-filter-externals">Externals</label></div></div><a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a></div></div></div></div><div class="tsd-page-title"><div class="container"><h1> ucan-storage</h1></div></div></header><div class="container container-main"><div class="row"><div class="col-8 col-content"><div class="tsd-panel tsd-typography">
<a href="#ucanstorage" id="ucanstorage" style="color: inherit; text-decoration: none;">
  <h1>UCAN.Storage</h1>
</a>
<p>This project defines a <a href="https://github.com/nftstorage/ucan.storage/blob/main/spec.md">specification</a> for delegated authorization of decentralized storage services using <a href="https://ucan.xyz/">UCAN</a>, or User Controlled Authorization Networks.</p>
<p>UCAN.Storage was designed to be used with <a href="https://nft.storage">NFT.Storage</a> and <a href="https://web3.storage">Web3.Storage</a>, which both provide storage services backed by the <a href="https://filecoin.io">Filecoin</a> network, with content retrieval via the <a href="https://ipfs.io">InterPlanetary File System (IPFS)</a>.</p>
<p>This repository also contains the reference implementation of the <a href="https://github.com/nftstorage/ucan.storage/blob/main/spec.md">spec</a>, in the form of a JavaScript package called <code>ucan-storage</code>. See the <a href="#use-cases">Use cases</a> section below to see how it can be used, along with some example code for each use case.</p>

<a href="#how-it-works" id="how-it-works" style="color: inherit; text-decoration: none;">
  <h2>How it works</h2>
</a>
<p>Authorization using UCANs works differently than many other authorization schemes, so it&#39;s worth taking a moment to understand the terms and concepts involved.</p>
<p>First, we have a <strong>storage service</strong>, for example, <a href="https://nft.storage">NFT.Storage</a>. Normally (without UCAN), when a user signs up for an account at NFT.Storage, the service will give them an API token to authenticate and authorize uploads. This is standard Web 2 auth, and it works great, but it has some limitations, especially if you want to use NFT.Storage to provide services for your own end users.</p>
<p>For example, if you&#39;re building an NFT marketplace and want users to upload art to NFT.Storage before minting, you can&#39;t put your API token into the source code for your web application without exposing it to the world. Since your API token includes more permissions than just uploading, like deleting uploads from your account, this isn&#39;t a great solution. You could work around this by running a proxy server that hides your token from your users and attaches it to storage requests, but this means you need to relay all traffic through your server and pay for bandwidth costs.</p>
<p>UCAN provides a way for the storage service to issue a special kind of authorization token called a UCAN token. UCAN tokens can be used to derive &quot;child&quot; UCAN tokens, which can have a subset of the permissions encoded in the &quot;parent&quot; UCAN.</p>
<p>Participants in the UCAN auth flow are identified by a <strong>keypair</strong>, which is a <strong>private signing key</strong> with a corresponding <strong>public verification key</strong>. Each user or service involved in the flow will have their own keypair. The public key for each user or service is encoded into a <a href="https://www.w3.org/TR/did-core/">Decentralized Identity Document (DID)</a>, using the <a href="https://w3c-ccg.github.io/did-method-key/">did:key method</a>, which encodes the public key into a compact string of the form <code>did:key:&lt;encoded-public-key&gt;</code>. These DID strings are used to identify each of the participants in the UCAN flow.</p>
<p>UCAN tokens are standard <a href="https://jwt.io/">JSON Web Tokens (JWTs)</a> with some additional properties that allow the kind of delegated chains of authority we&#39;ve been describing. The <a href="https://ucan.xyz/#the-ucan-data-structure">UCAN data structure</a> specifies some required properties of the JWT payload, some of which, like <code>iss</code> and <code>aud</code> are standard fields in the JWT spec.</p>
<p>The <code>iss</code> or &quot;issuer&quot; field contains the public key that issued the token, encoded as a DID. The public key can be used to verify the token&#39;s signature, which must be created with the corresponding private signing key.</p>
<p>The <code>aud</code> or &quot;audience&quot; field contains the public key that should <em>receive</em> the token.</p>
<p>The <code>nbf</code> or &quot;not before&quot; and <code>exp</code> or &quot;expiry&quot; fields contain <a href="https://www.unixtimestamp.com/">Unix timestamps</a> that can be used to control the time window during which the token should be considered valid.</p>
<p>The <code>prf</code> or &quot;proof&quot; field contains the &quot;chain of proofs&quot; that validates the delegated chain of authority.</p>
<p>The <code>att</code> or &quot;attenuations&quot; field specifies the permissions that the token should grant to the bearer. These are described in the <a href="#storage-capabiliites">Storage capabilities</a> section below, and in greater detail in the <a href="https://github.com/nftstorage/ucan.storage/blob/main/spec.md">UCAN.Storage spec</a>.</p>
<p>To illustrate the authorization flow, let&#39;s walk through an example using NFT.Storage as the storage service and an NFT marketplace that wants to allow their users to upload to NFT.Storage.</p>
<p>First, the marketplace will generate a keypair and register their DID with the storage service, then ask the service to issue them a <strong>root token</strong>. The root token is a UCAN token that encodes all the permissions that the marketplace account is allowed to perform. The <code>iss</code> field of the root token will be the DID for the storage service, and the <code>aud</code> field will be the DID for the marketplace.</p>
<p>When an end-user logs into the marketplace and wants to upload to NFT.Storage, the marketplace can use their root token to create a <strong>user token</strong>. This time, the <code>iss</code> field contains the DID for the marketplace, since they are the one issuing the token, and the <code>aud</code> field contains the DID of the end user. The <code>prf</code> or &quot;proof&quot; field of the user token will contain a copy of the marketplace&#39;s root token, to verify that they actually have the permissions they&#39;re attempting to delegate. The root token is safe to share with the end-user, because it cannot be &quot;redeemed&quot; for storage services without the marketplace&#39;s private key.</p>
<p>When issuing the user token, the marketplace can choose to grant all the permissions that they have access to via the root token, or they can grant a subset of the permissions. The marketplace can also set an expiration time for the user tokens, so that a lost or compromised token will eventually expire. See <a href="#storage-capabiliites">Storage capabilities</a> below for more about the permissions available.</p>
<p>Once a marketplace end-user has a user token, they&#39;ll create one last token, a <strong>request token</strong> that authorizes their upload request to the NFT.Storage service. The request token is generated <em>by the user</em>, most likely in the browser with JavaScript, and it must include a signature from their private key.</p>
<p>The request token has the end-user&#39;s DID in the <code>iss</code> field, with the DID for the NFT.Storage service in the <code>aud</code> field. The <code>prf</code> field contains a copy of the user token that was issued by the marketplace, which in turn has the root token in its own <code>prf</code> field.</p>
<p>The request token is attached to the upload to NFT.Storage, which validates the chain of proofs encoded in the token and confirms the cryptographic identity of each participant by checking the token signatures. If the token is valid and the permissions encoded in the request token are sufficient to carry out the request, it will succeed.</p>

<a href="#storage-capabilities" id="storage-capabilities" style="color: inherit; text-decoration: none;">
  <h3>Storage capabilities</h3>
</a>
<p>UCAN tokens encode permissions as a set of &quot;capabilities,&quot; which are objects describing actions that the token holder can perform upon some &quot;resource.&quot;</p>
<p>UCAN.Storage supports the <code>storage</code> capability, which represents access to operations over storage resources (e.g., uploading a file to NFT.Storage).</p>
<p>A capability object looks like this:</p>
<pre><code class="language-json"><span class="hl-0">{</span><br/><span class="hl-0">  </span><span class="hl-1">&quot;with&quot;</span><span class="hl-0">: </span><span class="hl-2">&quot;storage://did:key:&lt;user-public-key&gt;&quot;</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-1">&quot;can&quot;</span><span class="hl-0">: </span><span class="hl-2">&quot;upload/*&quot;</span><br/><span class="hl-0">}</span>
</code></pre>
<p>The <code>with</code> field specifies the <strong>resource pointer</strong>, which in the case of UCAN.Storage is a string that includes the DID of the user to whom the token was issued. A <code>storage</code> resource pointer issued by a service that supports UCAN.Storage will always begin with the <code>storage://</code> prefix, followed by the DID that the token was issued to (the &quot;audience&quot; of the token).</p>
<p>When deriving child tokens for a new user, you will probably want to restrict that user&#39;s access to a sub-path of your storage. A simple way to do this is to append the DID of the new user to the resource path, with <code>/</code> characters separating the DID strings. For example, if your DID is <code>did:key:marketplace</code>, the token issued by the storage service would have the resource <code>storage://did:key:marketplace</code>. You can then issue a token to a user with the DID <code>did:key:user-1</code> and a resource path of <code>storage://did:key:marketplace/did:key:user-1</code>.</p>
<p>The <code>can</code> field specifies what <strong>action</strong> the token holder is authorized to perform. UCAN.Storage currently supports two actions, <code>upload/*</code> and <code>upload/IMPORT</code>.</p>
<p>The <code>upload/*</code> or &quot;upload all&quot; action allows access to all upload operations under the given resource.</p>
<p>The <code>upload/IMPORT</code> action allows access to upload a specific Content Archive (CAR), identified by the <a href="https://github.com/multiformats/multihash">multihash</a> of the CAR data.</p>
<p>See the <a href="https://github.com/nftstorage/ucan.storage/blob/main/spec.md">UCAN.Storage spec</a> for more details.</p>

<a href="#installation-and-usage" id="installation-and-usage" style="color: inherit; text-decoration: none;">
  <h2>Installation and usage</h2>
</a>
<p>You can install the <code>ucan-storage</code> package with your favorite JS dependency manager, e.g.:</p>
<pre><code class="language-bash"><span class="hl-0">npm install ucan-storage</span>
</code></pre>
<p>The main exports are the <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#build"><code>build</code></a> and <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#validate"><code>validate</code></a> methods, as well as the [<code>KeyPair</code> class][typedoc-keypair] used to manage signing keys.</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">build</span><span class="hl-0">, </span><span class="hl-4">validate</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/ucan-storage&#39;</span><br/><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">KeyPair</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/keypair&#39;</span>
</code></pre>

<a href="#using-the-ucan-storage-command-line-tool" id="using-the-ucan-storage-command-line-tool" style="color: inherit; text-decoration: none;">
  <h2>Using the <code>ucan-storage</code> command-line tool</h2>
</a>
<p>The <code>ucan-storage</code> package includes a command-line interface (CLI) that can help create keypairs and to create and validate UCAN tokens.</p>
<p>The <code>ucan-storage</code> command will be available if you install the package globally with <code>npm install -g ucan-storage</code>. Alternatively, you can run without installing globally by using <code>npx</code>:</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage --help</span>
</code></pre>
<p>The first time you run a command with <code>npx</code>, you&#39;ll get a prompt like this:</p>
<pre><code class="language-bash"><span class="hl-0">Need to install the following packages:</span><br/><span class="hl-0">  ucan-storage</span><br/><span class="hl-0">Ok to proceed? (y)</span>
</code></pre>
<p>Answer <code>y</code> to make the command available to <code>npx</code>.</p>

<a href="#use-cases" id="use-cases" style="color: inherit; text-decoration: none;">
  <h2>Use cases</h2>
</a>
<p>The <code>ucan-storage</code> JavaScript package supports the creation and verification of UCAN tokens, including the ability to create the &quot;proof chains&quot; that enable delgated authorization.</p>
<p>This README will walk through some common scenarios, to illustrate the main features of the <code>ucan-storage</code> library. For more details, see the <a href="https://nftstorage.github.io/ucan.storage/">API reference documentation</a>.</p>

<a href="#generating-a-keypair" id="generating-a-keypair" style="color: inherit; text-decoration: none;">
  <h3>Generating a keypair</h3>
</a>
<p>To participate in the UCAN flow (both as a service, and as an end-user), you&#39;ll need a keypair.</p>
<p>To generate a keypair using <code>ucan-storage</code>, use the static <a href="https://nftstorage.github.io/ucan.storage/classes/keypair.KeyPair.html#create"><code>KeyPair.create</code> method</a>:</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">KeyPair</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/keypair&#39;</span><br/><br/><span class="hl-5">// KeyPair.create returns a promise, so it should be called from an async function or resolved with `.then`</span><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">createNewKeypair</span><span class="hl-0">() {</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">kp</span><span class="hl-0"> = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-4">KeyPair</span><span class="hl-0">.</span><span class="hl-7">create</span><span class="hl-0">()</span><br/><br/><span class="hl-0">  </span><span class="hl-5">// log the DID string for the public key to the console:</span><br/><span class="hl-0">  </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">log</span><span class="hl-0">(</span><span class="hl-4">kp</span><span class="hl-0">.</span><span class="hl-7">did</span><span class="hl-0">())</span><br/><span class="hl-0">}</span>
</code></pre>
<p>To generate a keypair using the <a href="#using-the-ucan-storage-command-line-tool">CLI</a>, use the <code>ucan-storage keypair</code> command:</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage keypair</span>
</code></pre>
<p>You should see output similar to this:</p>
<pre><code><span class="hl-9">DID</span><span class="hl-0">:           </span><span class="hl-9">did</span><span class="hl-0">:</span><span class="hl-9">key</span><span class="hl-0">:</span><span class="hl-4">z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg</span><br/><span class="hl-4">Public</span><span class="hl-0"> </span><span class="hl-9">Key</span><span class="hl-0">:    9</span><span class="hl-4">U6gpYLouaQ2az2YlIWqBUQX1KWNiyDFmpVNZMcLBw8</span><span class="hl-0">=</span><br/><span class="hl-4">Private</span><span class="hl-0"> </span><span class="hl-9">Key</span><span class="hl-0">:   </span><span class="hl-4">sCpzGR3vC7qHGxhT7Wg6yvbhvHQABigLH</span><span class="hl-0">+</span><span class="hl-10">0</span><span class="hl-0">+</span><span class="hl-4">egJrV6o</span><span class="hl-0">=</span>
</code></pre>
<p><strong>Important</strong>: when saving to disk, take care to save your private key in a secure location!</p>

<a href="#saving-and-loading-keypairs" id="saving-and-loading-keypairs" style="color: inherit; text-decoration: none;">
  <h3>Saving and loading keypairs</h3>
</a>
<p>You can export your private key to a string that can be saved to disk with the <a href="https://nftstorage.github.io/ucan.storage/classes/keypair.KeyPair.html#export"><code>export</code> method</a> and load an exported key with the static <a href="https://nftstorage.github.io/ucan.storage/classes/keypair.KeyPair.html#fromExportedKey"><code>fromExportedKey</code> method</a>:</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> </span><span class="hl-4">fs</span><span class="hl-0"> </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;fs&#39;</span><br/><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">KeyPair</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/keypair&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">createAndSaveKeypair</span><span class="hl-0">(</span><span class="hl-4">outputFilename</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">kp</span><span class="hl-0"> = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-4">KeyPair</span><span class="hl-0">.</span><span class="hl-7">create</span><span class="hl-0">()</span><br/><span class="hl-0">  </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-4">fs</span><span class="hl-0">.</span><span class="hl-4">promises</span><span class="hl-0">.</span><span class="hl-7">writeFile</span><span class="hl-0">(</span><span class="hl-4">kp</span><span class="hl-0">.</span><span class="hl-7">export</span><span class="hl-0">())</span><br/><span class="hl-0">  </span><span class="hl-3">return</span><span class="hl-0"> </span><span class="hl-4">kp</span><br/><span class="hl-0">}</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">loadKeyPairFromFile</span><span class="hl-0">(</span><span class="hl-4">keypairFilename</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">exportedKey</span><span class="hl-0"> = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-4">fs</span><span class="hl-0">.</span><span class="hl-4">promises</span><span class="hl-0">.</span><span class="hl-7">readFile</span><span class="hl-0">(</span><span class="hl-4">keypairFilename</span><span class="hl-0">)</span><br/><span class="hl-0">  </span><span class="hl-3">return</span><span class="hl-0"> </span><span class="hl-4">KeyPair</span><span class="hl-0">.</span><span class="hl-7">fromExportedKey</span><span class="hl-0">(</span><span class="hl-4">exportedKey</span><span class="hl-0">)</span><br/><span class="hl-0">}</span>
</code></pre>
<p><strong>Important</strong>: when saving to disk, take care to save your keys in a secure location!</p>
<p>You can get the public key and DID for a private key using the <code>ucan-storage keypair --from &lt;private-key&gt;</code> CLI command:</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage keypair --from sCpzGR3vC7qHGxhT7Wg6yvbhvHQABigLH+0+egJrV6o=</span>
</code></pre>
<p>Output:</p>
<pre><code><span class="hl-9">DID</span><span class="hl-0">:           </span><span class="hl-9">did</span><span class="hl-0">:</span><span class="hl-9">key</span><span class="hl-0">:</span><span class="hl-4">z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg</span><br/><span class="hl-4">Public</span><span class="hl-0"> </span><span class="hl-9">Key</span><span class="hl-0">:    9</span><span class="hl-4">U6gpYLouaQ2az2YlIWqBUQX1KWNiyDFmpVNZMcLBw8</span><span class="hl-0">=</span><br/><span class="hl-4">Private</span><span class="hl-0"> </span><span class="hl-9">Key</span><span class="hl-0">:   </span><span class="hl-4">sCpzGR3vC7qHGxhT7Wg6yvbhvHQABigLH</span><span class="hl-0">+</span><span class="hl-10">0</span><span class="hl-0">+</span><span class="hl-4">egJrV6o</span><span class="hl-0">=</span>
</code></pre>

<a href="#creating-a-ucan-token" id="creating-a-ucan-token" style="color: inherit; text-decoration: none;">
  <h3>Creating a UCAN token</h3>
</a>
<p>The <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#build"><code>build</code> function</a> is used to create new UCAN tokens from a <a href="https://nftstorage.github.io/ucan.storage/interfaces/ucan_storage._internal_.UcanStorageOptions.html"><code>UcanStorageOptions</code> input object</a>.</p>
<p>The <code>issuer</code> option must be set to a <a href="https://nftstorage.github.io/ucan.storage/classes/keypair.KeyPair.html"><code>KeyPair</code> object</a>. The private key will be used to sign the token, and the public key will be used to set the <code>iss</code> field in the token payload.</p>
<p>The <code>audience</code> option must contain the DID string for the recipient&#39;s public key.</p>
<p>The <code>capabilities</code> option must contain one or more <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage._internal_.html#StorageCapability"><code>StorageCapability</code></a> objects that represent the capabilities the token enables. If you are creating a token that derives capabilities from a &quot;parent&quot; UCAN token, the <code>capabilities</code> you pass in must be a <em>subset</em> of the capabilities granted by the parent UCAN. See the section on <a href="#storage-capabilities">Storage capabilities</a> to learn more.</p>
<p>When creating a &quot;child&quot; UCAN based on another &quot;parent&quot; UCAN, the parent token (in its JWT string form) should be included in the <code>proofs</code> array in the <code>UcanStorageOptions</code> object.</p>
<p>You can restrict the lifetime of the token by either setting an explicit <code>expiration</code> timestamp or setting a <code>lifetimeInSeconds</code> option. If both are set, <code>expiration</code> takes precedence.</p>
<p>You can also issue tokens that will become valid at a future date by setting the <code>notBefore</code> option to a timestamp in the future. If <code>notBefore</code> and <code>expiration</code> are both set, <code>notBefore</code> must be less than <code>expiration</code>.</p>
<p>Both timestamp options (<code>expiration</code> and <code>notBefore</code>) are Unix timestamps (seconds elapsed since the Unix epoch).</p>

<a href="#creating-a-root-token" id="creating-a-root-token" style="color: inherit; text-decoration: none;">
  <h4>Creating a root token</h4>
</a>
<p>You can create a &quot;root token&quot; with no parent by omitting the <code>proofs</code> field when calling the <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#build"><code>build</code> function</a>. This is generally only used in production by storage service providers (e.g. NFT.Storage) to issue tokens to users and marketplaces, but it is useful for all participants when writing tests, etc.</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">build</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/ucan-storage&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">makeRootToken</span><span class="hl-0">(</span><br/><span class="hl-0">  </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-4">audienceDID</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-4">actions</span><span class="hl-0"> = [</span><span class="hl-2">&#39;upload/*&#39;</span><span class="hl-0">]</span><br/><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-5">// make &quot;capability&quot; objects from the actions</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">capabilities</span><span class="hl-0"> = </span><span class="hl-4">actions</span><span class="hl-0">.</span><span class="hl-7">map</span><span class="hl-0">((</span><span class="hl-4">action</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> ({</span><br/><span class="hl-0">    </span><span class="hl-4">with:</span><span class="hl-0"> </span><span class="hl-2">`storage://</span><span class="hl-6">${</span><span class="hl-4">audienceDID</span><span class="hl-6">}</span><span class="hl-2">`</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">can:</span><span class="hl-0"> </span><span class="hl-4">action</span><span class="hl-0">,</span><br/><span class="hl-0">  }))</span><br/><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">token</span><span class="hl-0"> = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">build</span><span class="hl-0">({</span><br/><span class="hl-0">    </span><span class="hl-4">issuer:</span><span class="hl-0"> </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">audience:</span><span class="hl-0"> </span><span class="hl-4">audienceDID</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">capabilities</span><span class="hl-0">,</span><br/><span class="hl-0">  })</span><br/><span class="hl-0">}</span>
</code></pre>
<p>You can create a root token <a href="#using-the-ucan-storage-command-line-tool">CLI</a> with the <code>ucan-storage ucan</code> command.</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage ucan \</span><br/><span class="hl-0">  --audience did:key:z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg \</span><br/><span class="hl-0">  --with storage://did:key:z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg \</span><br/><span class="hl-0">  --can </span><span class="hl-2">&#39;upload/*&#39;</span>
</code></pre>
<p>Note that the example above omits the <code>--issuer</code> flag, so a new keypair will be randomly generated and used to sign the UCAN token. This is not very useful, so you should run the command with <code>--issuer &lt;your-private-key&gt;</code>.</p>
<p>It&#39;s also best to set an expiration time, so that the UCAN does not remain valid indefinitely. The <code>--expiration</code> flag accepts a timestamp in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 format</a>.</p>

<a href="#deriving-a-child-token" id="deriving-a-child-token" style="color: inherit; text-decoration: none;">
  <h4>Deriving a child token</h4>
</a>
<p>If you have a UCAN token, you can create a &quot;child token&quot; that derives capabilities from the parent token. To do so, include the parent token in the <code>proofs</code> array when calling <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#build">build</a>, and make sure that the <code>capabilities</code> you include do not exceed the capabilities in the parent token.</p>
<p>In this example, we first <a href="#validating-a-token">validate</a> the parent token, which returns the parsed UCAN payload. From the payload, we can retrieve the <a href="#storage-capabilities">capabilities</a> from the <code>att</code> field and extend the resource path to include the DID of the &quot;audience&quot; for the new token.</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">build</span><span class="hl-0">, </span><span class="hl-4">validate</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/ucan-storage&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">deriveToken</span><span class="hl-0">(</span><span class="hl-4">parentUCAN</span><span class="hl-0">, </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">, </span><span class="hl-4">audienceDID</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-5">// validate the parent UCAN and extract the payload</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">payload</span><span class="hl-0"> } = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">validate</span><span class="hl-0">(</span><span class="hl-4">parentUCAN</span><span class="hl-0">)</span><br/><br/><span class="hl-0">  </span><span class="hl-5">// the `att` field contains the capabilities</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">att</span><span class="hl-0"> } = </span><span class="hl-4">payload</span><br/><br/><span class="hl-0">  </span><span class="hl-5">// for each capability in the parent, keep everything except the</span><br/><span class="hl-0">  </span><span class="hl-5">// resource path, to which we append the DID for the new token&#39;s audience</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">capabilities</span><span class="hl-0"> = </span><span class="hl-4">att</span><span class="hl-0">.</span><span class="hl-7">map</span><span class="hl-0">((</span><span class="hl-4">capability</span><span class="hl-0">) </span><span class="hl-6">=&gt;</span><span class="hl-0"> ({</span><br/><span class="hl-0">    ...</span><span class="hl-4">capability</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">with:</span><span class="hl-0"> [</span><span class="hl-4">capability</span><span class="hl-0">.</span><span class="hl-4">with</span><span class="hl-0">, </span><span class="hl-4">audienceDID</span><span class="hl-0">].</span><span class="hl-7">join</span><span class="hl-0">(</span><span class="hl-2">&#39;/&#39;</span><span class="hl-0">),</span><br/><span class="hl-0">  }))</span><br/><br/><span class="hl-0">  </span><span class="hl-5">// include the parent UCAN JWT string in the proofs array</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">proofs</span><span class="hl-0"> = [</span><span class="hl-4">parentUCAN</span><span class="hl-0">]</span><br/><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">token</span><span class="hl-0"> = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">build</span><span class="hl-0">({</span><br/><span class="hl-0">    </span><span class="hl-4">issuer:</span><span class="hl-0"> </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">audience:</span><span class="hl-0"> </span><span class="hl-4">audienceDID</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">capabilities</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">proofs</span><span class="hl-0">,</span><br/><span class="hl-0">  })</span><br/><span class="hl-0">}</span>
</code></pre>
<p>You can also use the <a href="#using-the-ucan-storage-command-line-tool">CLI</a> to derive child UCAN tokens by adding the <code>--proof</code> flag when calling the <code>ucan-storage ucan</code> command:</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage ucan \</span><br/><span class="hl-0">  --audience did:key:z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg \</span><br/><span class="hl-0">  --with storage://did:key:z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg \</span><br/><span class="hl-0">  --can </span><span class="hl-2">&#39;upload/*&#39;</span><span class="hl-0"> \</span><br/><span class="hl-0">  --proof eyJhb...etc...</span>
</code></pre>
<p>Pass in complete parent UCAN token as the argument to the <code>--proof</code> flag to include it in the proof chain of the generated token.</p>

<a href="#creating-a-request-token-to-upload-content" id="creating-a-request-token-to-upload-content" style="color: inherit; text-decoration: none;">
  <h4>Creating a request token to upload content</h4>
</a>
<p>When uploading content to the storage service, the user will need to generate a UCAN token using their keypair and attach this &quot;request token&quot; to the upload request in a header.</p>
<p>This token must have the DID for the storage service as the <code>audience</code>, with the end-user&#39;s DID as the <code>issuer</code>.</p>
<p>The chain of <code>proofs</code> must include a UCAN token issued by the storage service, and the token must include capabilities sufficient to serve the request. This &quot;proof token&quot; may be issued by the storage service itself, or by a third party like an NFT marketplace who has <a href="#deriving-a-child-token">derived a child token</a> to delegate storage services to end users.</p>
<p>The <code>capabilites</code> field for the request token should include the capabilites from UCAN token that was issued to the user. These are found in the <code>att</code> field of the UCAN token payload and can be copied into the request token unmodified.</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">build</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/ucan-storage&#39;</span><br/><br/><span class="hl-5">// The DID for the storage service. In real code, you should obtain this from the service you&#39;re targetting.</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">serviceDID</span><span class="hl-0"> = </span><span class="hl-2">&#39;did:key:a-fake-service-did&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">createRequestToken</span><span class="hl-0">(</span><span class="hl-4">parentUCAN</span><span class="hl-0">, </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-5">// we want to include the capabilities of the parent token in our request token</span><br/><span class="hl-0">  </span><span class="hl-5">// so we validate the parent token to extract the payload and copy over the capabilities</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">payload</span><span class="hl-0"> } = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">validate</span><span class="hl-0">(</span><span class="hl-4">parentUCAN</span><span class="hl-0">)</span><br/><br/><span class="hl-0">  </span><span class="hl-5">// the `att` field contains the capabilities we need for uploading</span><br/><span class="hl-0">  </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">att</span><span class="hl-0"> } = </span><span class="hl-4">payload</span><br/><br/><span class="hl-0">  </span><span class="hl-3">return</span><span class="hl-0"> </span><span class="hl-7">build</span><span class="hl-0">({</span><br/><span class="hl-0">    </span><span class="hl-4">issuer:</span><span class="hl-0"> </span><span class="hl-4">issuerKeyPair</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">audience:</span><span class="hl-0"> </span><span class="hl-4">serviceDID</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">capabilities:</span><span class="hl-0"> </span><span class="hl-4">att</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-4">proofs:</span><span class="hl-0"> [</span><span class="hl-4">parentUcan</span><span class="hl-0">],</span><br/><span class="hl-0">  })</span><br/><span class="hl-0">}</span>
</code></pre>

<a href="#setting-an-expiration-date" id="setting-an-expiration-date" style="color: inherit; text-decoration: none;">
  <h4>Setting an expiration date</h4>
</a>
<p>When creating a UCAN, you can set it to expire at a certain date by setting the <code>lifetimeInSeconds</code> or <code>expiration</code> options when calling <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#build"><code>build</code></a>.</p>
<p>The <code>expiration</code> option sets a point in time at which the token will expire. All parties in the UCAN flow should reject tokens with <code>expiration</code> dates in the past.</p>
<p>You can create tokens that will not be valid unitl a time in the future by setting the <code>notBefore</code> option.</p>
<p>Both <code>expiration</code> and <code>notBefore</code> are Unix timestamps, which record the number of seconds elapsed since the start of the Unix &quot;epoch&quot;. JavaScript&#39;s <code>Date.now()</code> method returns epoch timestamps with millisecond resolution, so to get the correct value you must divide by 1000:</p>
<pre><code class="language-js"><span class="hl-5">// convert timestamp to seconds</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">nowInSeconds</span><span class="hl-0"> = </span><span class="hl-11">Math</span><span class="hl-0">.</span><span class="hl-7">floor</span><span class="hl-0">(</span><span class="hl-11">Date</span><span class="hl-0">.</span><span class="hl-7">now</span><span class="hl-0">() / </span><span class="hl-10">1000</span><span class="hl-0">)</span><br/><br/><span class="hl-5">// expire in one minute</span><br/><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">expiration</span><span class="hl-0"> = </span><span class="hl-4">nowInSeconds</span><span class="hl-0"> + </span><span class="hl-10">60</span>
</code></pre>
<p>The <code>lifetimeInSeconds</code> option is a helper to set the <code>expiration</code> date relative to the current time, or the <code>notBefore</code> time if specified.</p>
<p>When creating UCAN tokens using the <a href="#using-the-ucan-storage-command-line-tool">CLI</a>, pass in an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>-formatted timestamp to the <code>--expiration</code> flag.</p>
<p>Here&#39;s an example of generating an ISO 8601 date for 10 minutes past the current time on a few platforms:</p>
<p>macOS / BSD coreutils:</p>
<pre><code class="language-bash"><span class="hl-0">date +%Y-%m-%dT%H:%M:%S%z -d </span><span class="hl-2">$(date)</span><span class="hl-0"> + 10 minutes</span>
</code></pre>
<p>GNU coreutils (found on most Linux distributions):</p>
<pre><code class="language-bash"><span class="hl-0">date --iso-8601=seconds -d </span><span class="hl-2">$(date)</span><span class="hl-0"> + 10 minutes</span>
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell"><span class="hl-0">(</span><span class="hl-7">Get-Date</span><span class="hl-0">).AddMinutes(</span><span class="hl-10">10</span><span class="hl-0">).Format(</span><span class="hl-2">&quot;o&quot;</span><span class="hl-0">)</span>
</code></pre>

<a href="#validating-a-token" id="validating-a-token" style="color: inherit; text-decoration: none;">
  <h4>Validating a token</h4>
</a>
<p>You can validate a UCAN token using the <a href="https://nftstorage.github.io/ucan.storage/modules/ucan_storage.html#validate"><code>validate</code> function</a>, which accepts a JWT string and returns the parsed token contents if the token is valid.</p>
<p>If validation fails, the <code>Promise</code> returned by <code>validate</code> will reject with an <code>Error</code>, so it&#39;s important to surround calls to <code>validate</code> with <code>try/catch</code> statements when calling from <code>async</code> functions, or use <code>.catch()</code> to handle errors if resolving <code>Promise</code>s manually.</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">validate</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage/ucan-storage&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">validateUCAN</span><span class="hl-0">(</span><span class="hl-4">ucanJWTString</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-3">try</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">header</span><span class="hl-0">, </span><span class="hl-8">payload</span><span class="hl-0">, </span><span class="hl-8">signature</span><span class="hl-0"> } = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">validate</span><span class="hl-0">(</span><span class="hl-4">ucanJWTString</span><span class="hl-0">)</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">log</span><span class="hl-0">(</span><span class="hl-2">&#39;UCAN is valid!&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">log</span><span class="hl-0">(</span><span class="hl-2">&#39;header:&#39;</span><span class="hl-0">, </span><span class="hl-4">header</span><span class="hl-0">)</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">log</span><span class="hl-0">(</span><span class="hl-2">&#39;payload:&#39;</span><span class="hl-0"> </span><span class="hl-4">payload</span><span class="hl-0">)</span><br/><span class="hl-0">  } </span><span class="hl-3">catch</span><span class="hl-0"> (</span><span class="hl-4">err</span><span class="hl-0">) {</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">error</span><span class="hl-0">(</span><span class="hl-2">&#39;UCAN validation failed: &#39;</span><span class="hl-0">, </span><span class="hl-4">err</span><span class="hl-0">)</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span>
</code></pre>
<p>You can make the validation more lenient by passing in a <a href="https://nftstorage.github.io/ucan.storage/interfaces/ucan_storage._internal_.ValidateOptions.html"><code>ValidateOptions</code> object</a> and disabling the validation checks you want to skip. For example, if you want to ignore the <code>notBefore</code> timestamp, you can set the <code>checkIsTooEarly</code> option to <code>false</code>:</p>
<pre><code class="language-js"><span class="hl-3">import</span><span class="hl-0"> { </span><span class="hl-4">validate</span><span class="hl-0"> } </span><span class="hl-3">from</span><span class="hl-0"> </span><span class="hl-2">&#39;ucan-storage&#39;</span><br/><br/><span class="hl-6">async</span><span class="hl-0"> </span><span class="hl-6">function</span><span class="hl-0"> </span><span class="hl-7">validateIgnoringEarlyBirds</span><span class="hl-0">(</span><span class="hl-4">ucanJWTString</span><span class="hl-0">) {</span><br/><span class="hl-0">  </span><span class="hl-3">try</span><span class="hl-0"> {</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> </span><span class="hl-8">validateOptions</span><span class="hl-0"> = {</span><br/><span class="hl-0">      </span><span class="hl-4">checkIsTooEarly:</span><span class="hl-0"> </span><span class="hl-6">false</span><span class="hl-0">,</span><br/><span class="hl-0">    }</span><br/><span class="hl-0">    </span><span class="hl-6">const</span><span class="hl-0"> { </span><span class="hl-8">header</span><span class="hl-0">, </span><span class="hl-8">payload</span><span class="hl-0">, </span><span class="hl-8">signature</span><span class="hl-0"> } = </span><span class="hl-3">await</span><span class="hl-0"> </span><span class="hl-7">validate</span><span class="hl-0">(</span><br/><span class="hl-0">      </span><span class="hl-4">ucanJWTString</span><span class="hl-0">,</span><br/><span class="hl-0">      </span><span class="hl-4">validateOptions</span><br/><span class="hl-0">    )</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">log</span><span class="hl-0">(</span><span class="hl-2">&#39;UCAN is valid! Early? No problem!&#39;</span><span class="hl-0">)</span><br/><span class="hl-0">  } </span><span class="hl-3">catch</span><span class="hl-0"> (</span><span class="hl-4">err</span><span class="hl-0">) {</span><br/><span class="hl-0">    </span><span class="hl-4">console</span><span class="hl-0">.</span><span class="hl-7">error</span><span class="hl-0">(</span><span class="hl-2">&#39;UCAN validation failed: &#39;</span><span class="hl-0">, </span><span class="hl-4">err</span><span class="hl-0">)</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">}</span>
</code></pre>
<p>You can validate a token using the CLI with the <code>ucan-storage validate</code> command:</p>
<pre><code class="language-bash"><span class="hl-0">npx ucan-storage validate eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCIsInVjdiI6IjAuOC4wIn0.eyJhdWQiOiJkaWQ6a2V5Ono2TWt2eHFVRE5ycTJRSmhzTW96SEpueFBESG12NktZcFU5Rm1LS3pXdnhiVWV3ZyIsImF0dCI6W3sid2l0aCI6InN0b3JhZ2U6Ly9kaWQ6a2V5Ono2TWt2eHFVRE5ycTJRSmhzTW96SEpueFBESG12NktZcFU5Rm1LS3pXdnhiVWV3ZyIsImNhbiI6InVwbG9hZC8qIn1dLCJleHAiOjE2NDY3NjkwNTAsImlzcyI6ImRpZDprZXk6ejZNa3NtRGRqVlAxWUhqd1pNd3FXaVFjWDFEWE00cGphNml5a2h6Q3hOZTlTaW5YIiwicHJmIjpbbnVsbF19.rOHzMzBWaFbH4tqS7aJ_4rBPkZbYQkck-fZLPD0skK3iRZUnxNUEFQITav5v70jzAwJIj757Xk2ImwOwmZ-4Dg</span>
</code></pre>
<p>Example output:</p>
<pre><code><span class="hl-9">Issuer</span><span class="hl-0">: </span><span class="hl-9">did</span><span class="hl-0">:</span><span class="hl-9">key</span><span class="hl-0">:</span><span class="hl-4">z6MksmDdjVP1YHjwZMwqWiQcX1DXM4pja6iykhzCxNe9SinX</span><br/><span class="hl-9">Audience</span><span class="hl-0">: </span><span class="hl-9">did</span><span class="hl-0">:</span><span class="hl-9">key</span><span class="hl-0">:</span><span class="hl-4">z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg</span><br/><span class="hl-9">Expires</span><span class="hl-0">: </span><span class="hl-10">2022</span><span class="hl-0">-</span><span class="hl-10">03</span><span class="hl-0">-08</span><span class="hl-9">T19</span><span class="hl-0">:</span><span class="hl-10">50</span><span class="hl-0">:50.000</span><span class="hl-8">Z</span><br/><span class="hl-9">Capabilities</span><span class="hl-0">: [</span><br/><span class="hl-0">  {</span><br/><span class="hl-0">    </span><span class="hl-2">&quot;with&quot;</span><span class="hl-4">:</span><span class="hl-0"> </span><span class="hl-2">&quot;storage://did:key:z6MkvxqUDNrq2QJhsMozHJnxPDHmv6KYpU9FmKKzWvxbUewg&quot;</span><span class="hl-0">,</span><br/><span class="hl-0">    </span><span class="hl-2">&quot;can&quot;</span><span class="hl-4">:</span><span class="hl-0"> </span><span class="hl-2">&quot;upload/*&quot;</span><br/><span class="hl-0">  }</span><br/><span class="hl-0">]</span><br/><span class="hl-9">Proofs</span><span class="hl-0">: [</span><br/><span class="hl-0">  </span><span class="hl-6">null</span><br/><span class="hl-0">]</span>
</code></pre>

<a href="#using-ucans-with-nftstorage" id="using-ucans-with-nftstorage" style="color: inherit; text-decoration: none;">
  <h2>Using UCANs with NFT.Storage</h2>
</a>
<!-- TODO: move this section into the NFT.Storage docs & link from here -->

<p><em>Use of UCANs to delegate upload permissions in NFT.Storage is currently a Preview Feature. If you use and have any feedback, please leave feedback in <a href="https://github.com/nftstorage/nft.storage/discussions/1591">this Github Discussion</a>!</em></p>
<p><a href="https://nft.storage">NFT.Storage</a> is a free service for storing NFT data on the decentralized <a href="https://filecoin.io">Filecoin</a> storage network, with content retrieval via <a href="https://ipfs.io">IPFS</a>.</p>
<p>NFT.Storage is the first service to support UCAN-based authorization using the <code>ucan-storage</code> library.</p>
<p>For marketplaces and other platforms, adopting UCAN auth can allow you to integrate free, decentralized NFT storage into your own applications without requiring your end users to sign up for an NFT.Storage account.</p>
<p>The NFT.Storage API includes endpoints for registering your DID with your NFT.Storage account and obtaining &quot;root tokens&quot; that can be used to delegate storage permissions to other users, whether they have an NFT.Storage account or not.</p>
<p>If you have not yet created an NFT.Storage account, see the <a href="https://nft.storage/docs">NFT.Storage documentation</a>.</p>
<p>To use the UCAN API endpoints, create an API token at your NFT.Storage <a href="https://nft.storage/manage/">account management page</a>.</p>

<a href="#registering-your-did" id="registering-your-did" style="color: inherit; text-decoration: none;">
  <h3>Registering your DID</h3>
</a>
<p>Once you have a normal API token, you can <a href="#generating-a-keypair">generate a keypair</a> using the <code>ucan-storage</code> CLI and call an API endpoint to register the DID of the public key with the NFT.Storage service.</p>
<p>To register your DID, send a <code>POST</code> request to <code>https://api.nft.storage/user/did</code> with a body containing a JSON object of the form:</p>
<pre><code class="language-json"><span class="hl-0">{</span><br/><span class="hl-0">  </span><span class="hl-1">&quot;did&quot;</span><span class="hl-0">: </span><span class="hl-2">&quot;&lt;your-did-string&gt;&quot;</span><br/><span class="hl-0">}</span>
</code></pre>
<p>In the example below, replace <code>$API_TOKEN</code> with your NFT.Storage API token, or set a shell variable named <code>API_TOKEN</code> before running the command.</p>
<p>Likewise, replace <code>$DID</code> with your DID string, or set a shell variable named <code>DID</code> before running the command.</p>
<pre><code class="language-bash"><span class="hl-0">curl -X POST -H </span><span class="hl-2">&quot;Authorization: Bearer </span><span class="hl-4">$API_TOKEN</span><span class="hl-2">&quot;</span><span class="hl-0"> -H </span><span class="hl-2">&#39;Content-Type: application/json&#39;</span><span class="hl-0"> --data </span><span class="hl-2">&quot;{</span><span class="hl-12">\&quot;</span><span class="hl-2">did</span><span class="hl-12">\&quot;</span><span class="hl-2">: </span><span class="hl-12">\&quot;</span><span class="hl-4">$DID</span><span class="hl-12">\&quot;</span><span class="hl-2">}&quot;</span>
</code></pre>

<a href="#obtaining-a-root-ucan-token" id="obtaining-a-root-ucan-token" style="color: inherit; text-decoration: none;">
  <h3>Obtaining a root UCAN token</h3>
</a>
<p>Once you&#39;ve registered your DID, you can request a root UCAN token from the NFT.Storage API, which will be valid for a duration of two weeks.</p>
<p>To request a root token, you must have either a normal API token or an existing root UCAN token. By providing an existing UCAN, you can &quot;refresh&quot; a token before it expires.</p>
<p>Send a <code>POST</code> request to <code>https://api.nft.storage/ucan/token</code> to obtain a new UCAN token.</p>
<p>In the example below, replace <code>$TOKEN</code> with either an existing UCAN token or an NFT.Storage API token. Or, set a shell variable named <code>TOKEN</code> before running the command.</p>
<pre><code class="language-bash"><span class="hl-0">curl -X POST -H </span><span class="hl-2">&quot;Authorization: Bearer </span><span class="hl-4">$TOKEN</span><span class="hl-2">&quot;</span><span class="hl-0"> https://api.nft.storage/ucan/token</span>
</code></pre>
<!-- TODO: show response body -->

<p>You can use the root token to <a href="#deriving-a-child-token">derive child UCAN tokens</a> for other users, or to <a href="#creating-a-request-token-to-upload-content">create a request token</a> to upload content using UCAN auth instead of your API token.</p>

<a href="#obtaining-the-service-did" id="obtaining-the-service-did" style="color: inherit; text-decoration: none;">
  <h3>Obtaining the service DID</h3>
</a>
<p>The DID for the NFT.Storage service is available at the public endpoint <code>https://api.nft.storage/did</code>.</p>
<p>Send a <code>GET</code> request to <code>https://api.nft.storage/did</code>, which should return a JSON object of the form:</p>
<pre><code class="language-json"><span class="hl-0">{</span><br/><span class="hl-0">  </span><span class="hl-1">&quot;ok&quot;</span><span class="hl-0">: </span><span class="hl-6">true</span><span class="hl-0">,</span><br/><span class="hl-0">  </span><span class="hl-1">&quot;value&quot;</span><span class="hl-0">: </span><span class="hl-2">&quot;&lt;service-did&gt;&quot;</span><br/><span class="hl-0">}</span>
</code></pre>
<p>The <code>value</code> field contains the service DID, which is used when <a href="#creating-a-request-token-to-upload-content">creating request tokens</a>.</p>

<a href="#contributing" id="contributing" style="color: inherit; text-decoration: none;">
  <h2>Contributing</h2>
</a>
<p>We use <code>pnpm</code> in this project and commit the <code>pnpm-lock.yaml</code> file.</p>

<a href="#install-dependencies" id="install-dependencies" style="color: inherit; text-decoration: none;">
  <h3>Install dependencies.</h3>
</a>
<pre><code class="language-bash"><span class="hl-5"># install all dependencies in the mono-repo</span><br/><span class="hl-0">pnpm install</span><br/><span class="hl-5"># setup git hooks</span><br/><span class="hl-0">npx simple-git-hooks</span>
</code></pre>
</div></div><div class="col-4 col-menu menu-sticky-wrap menu-highlight"><nav class="tsd-navigation primary"><ul><li class="current"><a href="modules.html">Modules</a></li><li class=" tsd-kind-module"><a href="modules/keypair.html">keypair</a></li><li class=" tsd-kind-module"><a href="modules/ucan_storage.html">ucan-<wbr/>storage</a></li></ul></nav></div></div></div><footer class="with-border-bottom"><div class="container"><h2>Legend</h2><div class="tsd-legend-group"><ul class="tsd-legend"><li class="tsd-kind-namespace"><span class="tsd-kind-icon">Namespace</span></li><li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li></ul><ul class="tsd-legend"><li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li></ul></div><h2>Settings</h2><p>Theme <select id="theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></p></div></footer><div class="container tsd-generator"><p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></div><div class="overlay"></div><script src="assets/main.js"></script></body></html>